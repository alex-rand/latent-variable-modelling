[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Latent Variable Modelling Workflow Reference",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "index.html#what-is-this",
    "href": "index.html#what-is-this",
    "title": "Latent Variable Modelling Workflow Reference",
    "section": "What is this?",
    "text": "What is this?\nThis is a book full of code to use when you want to do latent variable modelling. It gives suggested workflows I’ve cobbled together from a few different textbooks, and has worked examples with data from those textbooks or from open datasets I found online. When you need to do latent variable modelling for your research, you can use these workflows as a place to start.\nSpecifically, it seems like these are the sub-areas of latent variable modelling to know how to do:\n\nExploratory Factor Analysis;\nConfirmatory Factor Analysis;\nItem Response Theory;\nFull SEM;\nLongitudinal SEM.\n\nMaybe I’ll discover some other types of things along the way. It’s a lifelong journey haha."
  },
  {
    "objectID": "index.html#what-am-i-referencing",
    "href": "index.html#what-am-i-referencing",
    "title": "Latent Variable Modelling Workflow Reference",
    "section": "What am I referencing?",
    "text": "What am I referencing?\nThe first book on latent variable modelling I read was Gorsuch (1983). This was a nice conceptual introduction, but the applied examples were pretty whack. I’ve since found a few sources with data and R code to work with:\n\nLatent Variable Modelling with R, by Finch (2015). They helpfully provide all of the datasets here.\nPrinciples and Practice of Structural Equation Modeling, by Kline (2011). The publisher provides data and code here.\nThe lavaan documentation has some nice worked examples too.\n\nI’ll mostly be using lavaan and tidyverse, but maybe also some brms at some point.\n\n\n\n\nFinch, French, W. Holmes. 2015. Latent Variable Modeling with r.\n\n\nGorsuch, Richard L. 1983. Factor Analysis, 2nd Edition.\n\n\nKline, Rex B. 2011. Principles and Practice of Structural Equation Modeling."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "cfa.html#getting-started",
    "href": "cfa.html#getting-started",
    "title": "2  CFA",
    "section": "2.1 Getting started",
    "text": "2.1 Getting started\nLet’s load the packages we’ll need for what is to come in this chapter:\n\nlibrary(tidyverse)\nlibrary(lavaan)"
  },
  {
    "objectID": "cfa.html#example-1-toxic-striving-energy",
    "href": "cfa.html#example-1-toxic-striving-energy",
    "title": "2  CFA",
    "section": "2.2 Example 1: Toxic Striving Energy",
    "text": "2.2 Example 1: Toxic Striving Energy\nThe first example we’ll look at is from Finch (2015), chapter 3. The practice dataset is introduced on page 10. It is from a study about human motivation. The dataset is a weird questionnaire called the ‘Achievement Goal Scale’ (AGS), which asks people 12 questions about how much toxic striving energy they have. The dataset provided seems to have lots of mysterious columns in it, but we’re probably good to just keep the columns with responses to the AGS questionnaire:\n\n### Load the data\ndat_raw <- foreign::read.spss('data/finch-and-french/edps744.sav') \n  \n### Clean the data\ndat_ags <- dat_raw %>% \n\n  # Convert to a data frame for ease of use\n  as.data.frame() %>% \n  \n  # Keep only columns that start with the prefix 'ags' followed by a question number\n  select(matches(\"ags\\\\d\")) \n\n\n2.2.1 Data Exploration\nWe don’t want to do too much exploration before fitting our factor models, because the whole game of CFA is to commit to our hypotheses before checking what the data looks like, so we don’t mislead ourselves with forking paths. But just for fun, we can explore the distributions of the answers to each of the 12 questions:\n\ndat_ags %>% \n\n  # Pivot to prepare the data for visualization\n  pivot_longer(\n    cols      = everything(),\n    names_to  = \"question\",\n    values_to = \"response\",\n    names_transform = list(question = fct_inorder)  \n  ) %>% \n\n  # Plot\n  ggplot() +\n  geom_histogram(aes(x = response)) + \n  theme_bw() + \n  facet_wrap(~question)\n\n\n\n\nSeems like some questions have different means and variances from each other. For example, the answers to ags11 and ags12 are relatively flat, while the answers to ags4 and ags5 are more bunched up around the highest values. The responses clearly skew towards higher values in aggregate.\nWe can also do some healthy exploration of missingness in the dataset. For starters: what proportion of values are missing in each row?\n\ndat_ags %>% \n  \n  # Calculate the proportion of missing values \n  summarise_all(~ sum(is.na(.)) / (sum(is.na(.) + sum(!is.na(.))))) %>% \n  \n  # Rounding to make the results more presentable\n  mutate(across(everything(), round, 6)) %>% \n  \n  # Create the table\n  knitr::kable(title = \"Proportion of Missing Responses in Each Column\") \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nags1\nags2\nags3\nags4\nags5\nags6\nags7\nags8\nags9\nags10\nags11\nags12\n\n\n\n\n1.1e-05\n5e-06\n5e-06\n1.6e-05\n1.6e-05\n1.1e-05\n1.6e-05\n1.6e-05\n1.1e-05\n2.2e-05\n1.1e-05\n1.6e-05\n\n\n\n\n\nThat’s very little missingness. Probably no need to do multiple imputation here.\nThe authors also do a preliminary test of whether the responses are normally distributed, since this is one of the fundamental assumptions of maximum likelihood estimation. Kristoffer Magnusson has created a cool interactive teaching tool that nicely illustrates this point. It is worth remembering that we do not make this type of assumption for linear regression in general – only for maximum likelihood estimates. All we need assume for linear regression is that the residuals are normally distributed, as opposed to the data themselves. This common misunderstanding can lead researchers to commit what Richard McElreath has called ‘histomancy’.\nTo evaluate the assumption of normalness underlying maximum likelihood estimation, the authors do what seems to be a multivariate version of a classic ‘normal probability plot’. These are explained nicely in this stack exchange thread. They also produce some of the classic tests of skew and kurtosis, which I don’t want to get into here. This youtuber has nice introductory videos about these topics.\n\n# Run the Mardia tests for normalness\nmardia.object <- psych::mardia(dat_ags)\n\n\n\n# Plot the multivariate version of the normal probability plot\nplot(mardia.object)\n\n# Present the outputs we're interested in\ntibble(\n  \"Skew\" = mardia.object$skew,\n  \"Skew p-value\" = mardia.object$p.skew,\n  \"Kurtosis\" = mardia.object$kurtosis,\n  \"Kurtosis p-value\" = mardia.object$p.kurt\n) %>% \n  \n  knitr::kable()\n\n\n\n\nSkew\nSkew p-value\nKurtosis\nKurtosis p-value\n\n\n\n\n2359.475\n0\n40.52999\n0\n\n\n\n\n\nThe plotted points don’t seem to fit the straight line super well, which suggests that the normalness assumption may not hold here. Also, the hypothesis tests for skew and kurtosis return some mighty low p-values, suggesting that we’ve got lots of each of them. So maybe maximum likelihood estimation isn’t such a good idea here?\nThe authors proceed with it anyway for pedogogical reasons, because they want to illustrate how the maximum likelihood estimates differ from estimates arrived at using other methods.\n\n“In actual practice, given the lack of multivariate normality that seems apparent in the previous results, we would likely not use ML and instead rely on the alternative estimation approach.”\n\n\n\n2.2.2 Model Fitting\nThe researchers who collected the data do what good factor analysts do: they look to the literature to set up some clear and specific candidate hypotheses, and see the degree to which this new data is compatible with each of them.\nOne of the candidate hypotheses is that a person’s toxic striving energy (‘achievement goal orientedness’?) is secretly driven by four platonic unobservable things, namely:\n\nMastery Approach ‘MAP’ (eg. “I want to learn as much as possible”);\nMastery Avoidant ‘MAV’ (eg. “I want to avoid learning less than I possibly could”);\nPerformance Approach ‘PAP’ (eg. “I want to do well compared to other students”);\nPerformance Avoidant ‘PAV’ (eg. “It is important for me to avoid doing poorly compared to other students”)\n\nWe’ll call the above hypothesis H1. But there’s another hypothesis that says actually the ‘Mastery’ variables are just one monolithic thing, so really there are only 3 factors, namely ‘Mastery’, ‘PAP’, and ‘PAV’. We’ll call this one H2.\nThese will be the two candidate hypotheses we’re gonna test via factor analysis.\nThe way lavaan works is that you need to separately define the model syntax as a string, and then feed that string to one of the model-fitting functions like cfa() . Then we can call the summary() function to get a big table of outputs.\n\n# Define the relationships from my hypothesis\nh1.definition <- \n'map=~ags1+ags5+ags7\nmav=~ags2+ags6+ags12\npap=~ags3+ags9+ags11\npav=~ags4+ags8+ags10'\n\n# Fit the model\nh1.fit <- cfa(\n  data  = dat_ags,\n  model = h1.definition\n)\n\n# Look at the results\nh1.summary <- summary(h1.fit, fit.measures = TRUE, standardized = TRUE)\n\nh1.summary\n\nlavaan 0.6-12 ended normally after 48 iterations\n\n  Estimator                                         ML\n  Optimization method                           NLMINB\n  Number of model parameters                        30\n\n                                                  Used       Total\n  Number of observations                           419         432\n\nModel Test User Model:\n                                                      \n  Test statistic                               328.312\n  Degrees of freedom                                48\n  P-value (Chi-square)                           0.000\n\nModel Test Baseline Model:\n\n  Test statistic                              3382.805\n  Degrees of freedom                                66\n  P-value                                        0.000\n\nUser Model versus Baseline Model:\n\n  Comparative Fit Index (CFI)                    0.915\n  Tucker-Lewis Index (TLI)                       0.884\n\nLoglikelihood and Information Criteria:\n\n  Loglikelihood user model (H0)              -7014.070\n  Loglikelihood unrestricted model (H1)      -6849.914\n                                                      \n  Akaike (AIC)                               14088.141\n  Bayesian (BIC)                             14209.277\n  Sample-size adjusted Bayesian (BIC)        14114.078\n\nRoot Mean Square Error of Approximation:\n\n  RMSEA                                          0.118\n  90 Percent confidence interval - lower         0.106\n  90 Percent confidence interval - upper         0.130\n  P-value RMSEA <= 0.05                          0.000\n\nStandardized Root Mean Square Residual:\n\n  SRMR                                           0.055\n\nParameter Estimates:\n\n  Standard errors                             Standard\n  Information                                 Expected\n  Information saturated (h1) model          Structured\n\nLatent Variables:\n                   Estimate  Std.Err  z-value  P(>|z|)   Std.lv  Std.all\n  map =~                                                                \n    ags1              1.000                               0.840    0.746\n    ags5              0.774    0.057   13.564    0.000    0.650    0.682\n    ags7              1.100    0.064   17.263    0.000    0.924    0.895\n  mav =~                                                                \n    ags2              1.000                               0.923    0.627\n    ags6              0.974    0.078   12.523    0.000    0.899    0.796\n    ags12             1.039    0.096   10.805    0.000    0.959    0.644\n  pap =~                                                                \n    ags3              1.000                               1.284    0.840\n    ags9              0.853    0.038   22.349    0.000    1.095    0.870\n    ags11             1.103    0.052   21.178    0.000    1.416    0.841\n  pav =~                                                                \n    ags4              1.000                               0.929    0.771\n    ags8              1.599    0.084   19.091    0.000    1.486    0.855\n    ags10             1.525    0.073   20.861    0.000    1.418    0.921\n\nCovariances:\n                   Estimate  Std.Err  z-value  P(>|z|)   Std.lv  Std.all\n  map ~~                                                                \n    mav               0.709    0.079    9.000    0.000    0.914    0.914\n    pap               0.066    0.060    1.093    0.274    0.061    0.061\n    pav               0.056    0.043    1.289    0.197    0.072    0.072\n  mav ~~                                                                \n    pap               0.163    0.072    2.265    0.023    0.138    0.138\n    pav               0.178    0.053    3.355    0.001    0.207    0.207\n  pap ~~                                                                \n    pav               1.143    0.102   11.236    0.000    0.958    0.958\n\nVariances:\n                   Estimate  Std.Err  z-value  P(>|z|)   Std.lv  Std.all\n   .ags1              0.562    0.047   11.951    0.000    0.562    0.443\n   .ags5              0.486    0.038   12.780    0.000    0.486    0.535\n   .ags7              0.211    0.032    6.602    0.000    0.211    0.198\n   .ags2              1.312    0.102   12.825    0.000    1.312    0.606\n   .ags6              0.469    0.049    9.537    0.000    0.469    0.367\n   .ags12             1.300    0.103   12.669    0.000    1.300    0.586\n   .ags3              0.690    0.059   11.671    0.000    0.690    0.295\n   .ags9              0.386    0.036   10.769    0.000    0.386    0.244\n   .ags11             0.831    0.071   11.639    0.000    0.831    0.293\n   .ags4              0.588    0.045   12.959    0.000    0.588    0.405\n   .ags8              0.815    0.070   11.602    0.000    0.815    0.269\n   .ags10             0.362    0.043    8.423    0.000    0.362    0.153\n    map               0.706    0.083    8.514    0.000    1.000    1.000\n    mav               0.852    0.128    6.655    0.000    1.000    1.000\n    pap               1.648    0.158   10.416    0.000    1.000    1.000\n    pav               0.864    0.094    9.198    0.000    1.000    1.000\n\nsemPlot::semPaths(h1.fit)\n\n\n\n\nThat’s a lot of outputs. Let’s break down the output into smaller bite-sized chunks.\n\n\n2.2.3 Goodness of Fit Statistics\n\n2.2.3.1 Chi-Squared Statistic\nThe first thing to look at is the chi-squared statistic from the ‘User Model’, IE the model I, the user, have just fit. I like to think of this as a measure of how different the model’s reconstructed correlation matrix looks compared to the actual empirical correlation matrix of the data. So we use this statistic to test the null hypothesis “there is no significant difference between model’s reconstructed correlation matrix and the empirical one”. So, confusingly, we’re actually hoping to accept the null hypothesis here. This model returns a value of 328.312 with a vanishingly small p-value, so we reject the null hypothesis, which is bad: it suggests our model isn’t doing a good job replicating the empirical correlation matrix.\nHere’s a quote from Gorsuch (1983) that explains this stuff from the slightly different angle:\n\n“The test of significance [for a CFA model fit by maximum likelihood] gives a chi-square statistic with the null hypothesis being that all the population covariance has been extracted by the hypothesized number of factors. If the chi-square is significant at the designated probability level, then the residual matrix still has significant covariance in it.”\n\nSo this chi-squared statistic provides a first look at goodness-of-fit, but Finch (2015) say it is actually not very trustworthy in practice because the null hypothesis is sort of crazy: we want a more permissive test than just whether the model is perfectly recreating the empirical correlation matrix.\n\n“this statistic is not particularly useful in practice because it tests the null hypothesis that [the model-reconstructed correlation matrix is equal to the empirical correlation matrix], which is very restrictive. The test will almost certainly be rejected when the sample size is sufficiently large… In addition, the chi-square test relies on the assumption of multivariate normality of the indicators, which may not be tenable in many situations.”\n\nSo we’re gonna wanna look at statistics other than just chi-squared for goodness-of-fit, but it seems like a fine place to start. Let’s look at the chi-squared statistic of our model:\n\n### Create a nice summary table\ntibble(\n  Test             = \"standard chi-squared\",\n  `DF`             = h1.summary$test$standard$df,\n  `Test Statistic` = round(h1.summary$test$standard$stat, 2),\n  `p-value`        = h1.summary$test$standard$pvalue\n) %>% \n  \n  mutate(across(everything(), as.character)) %>% \n  \n  pivot_longer(everything()) %>% \n  \n  knitr::kable()\n\n\n\n\nname\nvalue\n\n\n\n\nTest\nstandard chi-squared\n\n\nDF\n48\n\n\nTest Statistic\n328.31\n\n\np-value\n0\n\n\n\n\n\nIt takes lots of skill and experience to have a sense of whether a test statistic is big or small given the degrees of freedom at play, but we can see from the p-value that we reject the null hypothesis in a big way. This is bad – it suggests that, given our assumptions, there’s a big difference between our model and the data.\n\n\n2.2.3.2 Root Mean Squared Error Approximation (RMSEA)\nAnother one people like to go with is the Root Mean Squared Error Approximation (RMSEA). This statistic takes some math and background to understand, which I’m not going to go over here. I found this document to be the clearest (but also pretty mathy) explanation.\nEssentially, RMSEA is a weighted sum of the discrepancies between the model’s reconstructed correlation matrix and the empirical correlation matrix. But it also does a nice thing where it discounts model complexity and sample size to help us not overfit. Here’s the definition:\n\\(\\text{RMSEA} = \\sqrt{\\dfrac{χ^2 - \\text{df}}{\\text{df}(n-1)}}\\)\nSee how it takes the chi-squared statistic and divides it by degrees of freedom (as a proxy for model complexity) and sample size? This makes for a more conservative measure of goodness-of-fit. Apparently the square-root is used “to return the index to the same metric as the original standardized parameters”. I don’t really understand that part… is it because a Chi-squared random variable is the squared version of a normal standard variable?\nAs with the raw chi-squared statistic, we want RMSEA to be small because it is intended as a measure of the distance between the empirical correlation matrix and the model-estimated correlation matrix. According to Finch (2015), people like to say:\n\nRMSEA <= 0.05 is a ‘good fit’;\n0.05 < RMSEA <= 0.08 is an ‘ok fit’\nRMSEA > .08 is a ‘bad fit’.\n\nLet’s check the RMSEA of our model:\n\n# make a nice summary table\nh1.summary$fit %>% \n  \n  as_tibble(rownames = \"stat\") %>% \n  \n  filter(str_detect(stat, \"rmsea\")) %>% \n  \n  knitr::kable()\n\n\n\n\nstat\nvalue\n\n\n\n\nrmsea\n0.1180574\n\n\nrmsea.ci.lower\n0.1061525\n\n\nrmsea.ci.upper\n0.1303058\n\n\nrmsea.pvalue\n0.0000000\n\n\n\n\n\nYikes – looks like our whole RMSEA, as well as its confidence interval, are above the ‘bad fit’ conventional threshold of .08. This corroborates what we saw with the chi-squared statistic above.\n\n\n2.2.3.3 Comparative Fit Index (CFI) and Tucker-Lewis Index (TLI)\nCFI seems to be the most trusted and widely-used tool for assessing goodness of fit in a CFA. Basically the idea is that we ask: “how much does the chi-squared statistic of my model differ from the chi-squared statistic of the worst model I can think of?”, where the conventional “worst model I can think of” is the model where I assume all of my observed variables are totally uncorrelated. This sort of has the opposite flavour of the deviance statistic I’m already familiar with, which compares the current model with “the best model I can think of.”\n\\(\\text{CFI} = 1 - \\dfrac{\\text{max}(χ^2_T - \\text{df}_T, 0)}{\\text{max}(χ^2_0 - \\text{df}_0, 0)}\\)\nActually, the numerator and denominator are both equal to the ‘non-centrality parameter’ of their respective candidate distributions. I’m not gonna get into this, but this is an idea that also shows up in power analysis as a way of comparing the null and candidate hypotheses.\nWe want to end up with a CFI as close to 1 as possible, because that suggests a big difference between my model and the worst possible model. So people say we can sort of think of this as analogous to \\(R^2\\) from linear regression. People seem to have adopted 0.95 as am arbitrary cutoff for ‘good fit’ for the CFI.\nIf you want to learn more about the CFI, I found this article a well-written resource.\nTucker-Lewis Index seems to be pretty similar to CFI, and we interpret it in the same way. Let’s look at both of them:\n\n# Make a nice summary table\nh1.summary$fit %>% \n  \n  as_tibble(rownames = \"stat\") %>% \n  \n  filter(str_detect(stat, \"cfi|tli\")) %>% \n  \n  knitr::kable()\n\n\n\n\nstat\nvalue\n\n\n\n\ncfi\n0.9154874\n\n\ntli\n0.8837951\n\n\n\n\n\nLooks like the CFI and TLI look ok, but don’t meet the conventional .95 cutoff. So they are in line with the chi-squared and RMSEA in suggesting that our goodness-of-fit isn’t so good.\n\n\n\n2.2.4 Factor Loadings & Convergent Validty\nThese are essentially just the regression coefficients of each factor on each of the outcome variables for which it was allowed to be a covariate. So we want them to be big and significant.\n\n### Make a nice summary table of the factor loadings\nh1.summary$pe %>% \n  \n  as_tibble() %>% \n  \n  # Keep only the rows with info on factor loadings\n  slice(1:12) %>% \n  \n  # Clean up the important values, then combine them into a single column\n  mutate(\n    std.all = round(std.all, 2),\n    std.all = paste0(std.all, \", pvalue = \", pvalue, \")\")\n  ) %>% \n  \n  # reformat the table\n  select(lhs, rhs, std.all) %>% \n  \n  pivot_wider(\n    names_from = \"lhs\", \n    values_from = \"std.all\",\n    values_fill = \"0\"\n  ) %>% \n  \n  column_to_rownames(\"rhs\") %>% \n  \n  knitr::kable(caption = \"Standardized factor loadings, standard errors, and p-values\")\n\n\nStandardized factor loadings, standard errors, and p-values\n\n\n\n\n\n\n\n\n\n\nmap\nmav\npap\npav\n\n\n\n\nags1\n0.75, pvalue = NA)\n0\n0\n0\n\n\nags5\n0.68, pvalue = 0)\n0\n0\n0\n\n\nags7\n0.9, pvalue = 0)\n0\n0\n0\n\n\nags2\n0\n0.63, pvalue = NA)\n0\n0\n\n\nags6\n0\n0.8, pvalue = 0)\n0\n0\n\n\nags12\n0\n0.64, pvalue = 0)\n0\n0\n\n\nags3\n0\n0\n0.84, pvalue = NA)\n0\n\n\nags9\n0\n0\n0.87, pvalue = 0)\n0\n\n\nags11\n0\n0\n0.84, pvalue = 0)\n0\n\n\nags4\n0\n0\n0\n0.77, pvalue = NA)\n\n\nags8\n0\n0\n0\n0.85, pvalue = 0)\n\n\nags10\n0\n0\n0\n0.92, pvalue = 0)\n\n\n\n\n\nRemember, my goal is to convince my research peers that the observed variables are actually providing a way of measuring the unobservable ‘factor’ I’m purporting to exist. One way of making this case is to look for Convergent Validity. Essentially what we’d like to see is that all of a factor’s variables load really highly on that factor, but also that they all load to more or less the same degree. In the words of Gorsuch (1983):\n\n“Convergent validity occurs when several variables deemed to measure the same construct correlate with each other…factor loadings of several variables hypothesized to relate to the construct can also be tested for significance. They could be specified as equal for the one model and the chi-square for that model subtracted from another hypothesized factor structure where they are allowed to vary. If the two differ significantly from each other, then one or more of the variables is more related to the construct than one or more of the other variables.”\n\nOr, as Kline (2011) puts it:\n\n“Variables presumed to measure the same construct show convergent validity if their intercorrelations are appreciable in magnitude.”\n\nFirstly, notice that all of the non-fixed loadings are highly statistically significant, with all p-values smaller than .01. This is good! Super statistically-significant loadings are a necessary sign that our measured variables are actually good proxies for the imaginary ‘latent’ factor we’re purporting to use them to measure.\nNext, Kline (2011) says that we can start assessing convergent validity by just looking at the standardized loadings can in isolation. In his words on page 344:\n\n“[with reference to a CFA model he has fit]: A few other standardized coefficients are rather low, such as .433 for the self-talk indicator of constructive thinking, so evidence for convergent validity is mixed.”\n\nNow let’s do what Gorsuch suggests in the above quote: we’ll fit another model that assumes all of the within-factor loadings are equal, and see if that results in a statistically significant reduction in goodness-of-fit. If it does, then we lose some evidence of convergent validity.\n\n\n\nThere’s another conventional thing people do to test for convergent validity, which neither Gorsuch (1983) nor Finch (2015) mention: we can look at the reliability of the measurements. This is a concept based on the assumption from classical test theory that every datapoint is the sum of a ‘true’ score and ‘noise’, where the ‘true’ score is the value of the latent variable. This is an ontologically dubious framing, but I guess a useful or at least traditional one. Anyway, people like to do things in hopes of estimating the proportion of the variance explained by the ‘true’ score as opposed to noise, and when they do these things they say they are estimating ‘reliability’. Ok.\nThe all-time classic ‘reliability’ measure is called Cronbach’s Alpha. Cronbach didn’t actually invent it, so hello Stigler’s Law. Here’s what it looks like:\n\\(\\alpha = (\\dfrac{k}{1-k}) (1 - \\dfrac{\\sum\\sigma_y^2}{\\sigma_T^2})\\)\nThe term on the right is doing most of the work: its denominator is the variance of the column that contains the rowwise sums of my dataset. Its numerator is the sum of the variances of each column. So we’re asking: ‘is the variance of the sums larger than the variance of the individual columns?’ This will be true if the columns are generally pretty correlated, because the sums will stack up the raw values, instead of them cancelling each other out. So really we’re just asking: are the columns generally pretty correlated?‘. If my columns are pretty correlated and I make the standard assumption that no other latent factors are influencing my observed values (an insane assumption), then I can feel comfortable saying that Cronbach’s Alpha is useful for figuring out whether my measurements are all loading on the same ’latent’ variable. Since the observed values are gonna be consistent with each other if this is true, people like to say that Cronbach’s Alpha gives a picture of ‘Internal Consistency Reliability’.\nLet’s calculate Cronbach’s Alpha for each of the subscales I’ve used to define my supposed factors:\n\n### Split the dataset into the subscales assumed by my factor model\nsubscales <- list(\n  map = dat_ags %>% select(ags1, ags5, ags7),\n  mav = dat_ags %>% select(ags2, ags6, ags12),\n  pap = dat_ags %>% select(ags3, ags9, ags11),\n  pav = dat_ags %>% select(ags4, ags8, ags10)\n)\n\n### Calculate Chronbach's Alpha for each subscale, then analyze.\nalphas <- subscales %>% \n  \n  map(psych::alpha) %>% \n  \n  map(summary) %>% \n  \n  knitr::kable() \n\n\nReliability analysis   \n raw_alpha std.alpha G6(smc) average_r S/N   ase mean  sd median_r\n      0.82      0.82    0.76       0.6 4.6 0.015  5.9 0.9      0.6\n\nReliability analysis   \n raw_alpha std.alpha G6(smc) average_r S/N   ase mean  sd median_r\n      0.77      0.77    0.71      0.52 3.3 0.018  5.3 1.2     0.45\n\nReliability analysis   \n raw_alpha std.alpha G6(smc) average_r S/N    ase mean  sd median_r\n      0.88      0.89    0.84      0.73 7.9 0.0095  5.4 1.3     0.74\n\nReliability analysis   \n raw_alpha std.alpha G6(smc) average_r S/N  ase mean  sd median_r\n      0.87      0.88    0.85       0.7 7.1 0.01  5.6 1.3     0.72\n\n\nAccording to Kline (2011), these all look like good results, so they help me feel good about claiming convergent validity:\n\n“Generally, coefficients around .90 are considered”excellent,” values around .80 as “very good,” and values about .70 as “adequate.””\n\nCronbach’s Alpha has some drawbacks as a measure of ‘reliability’, so Kline (2011) says to also calculate the Average Variance Extracted (AVE), which is simply the average of the within-factor squared factor loadings. This is based on the idea that a squared factor loading is the variance explained of the variable by that factor. The convention is that if the AVE > 0.5, then you can feel good about claiming convergent validity. I guess this makes sense – seems like a pretty simple and ad-hoc way of asking whether your loadings are generally on the same page. But obviously if I have lots of observed variables defining the factor then I’m at risk of having a bunch of high loadings and a bunch of low loadings, resulting in a misleadingly moderate average? To me it seems like we might as well just look at the raw loadings themselves – no need to look at an average here.\nBut just for fun, let’s calculate the AVE. Rather than doing it manually, we can use a ready-made function from the semTools package\n\nsemTools::AVE(h1.fit) %>% \n  \n  knitr::kable()\n\n\n\n\n\nx\n\n\n\n\nmap\n0.6115914\n\n\nmav\n0.4556936\n\n\npap\n0.7179750\n\n\npav\n0.7422385\n\n\n\n\n\nBased on the rule-of-thumb that we want the AVE to be at least .50, it seems like the ‘mav’ factor is having some trouble. It also had the lowest Cronbach Alpha. So maybe the observed variables I’m using to measure it aren’t actually doing a great job? This hurts convergent validity for that factor.\nLastly, we can also try to measure this unicorn of ‘reliability’ by just directly asking “what proportion of the total variance is explained by the factor model?”. People like to do this by summing all the factor loadings, squaring that sum, and dividing it by itself plus the sum of the residual variances of the variables (IE dividing it by the total empirical variance of the variable). They call this one the Composite Reliability (CR).\n\nsemTools::compRelSEM(h1.fit) %>% \n  \n  knitr::kable()\n\n\n\n\n\nx\n\n\n\n\nmap\n0.8164263\n\n\nmav\n0.6689921\n\n\npap\n0.8803380\n\n\npav\n0.9016062\n\n\n\n\n\nApparently the rule of thumb for this one is the same as for Cronbach’s Alpha. So we can feel good about all of them except for ‘mav’, which has taken a beating via these 3 checks.\nKline (2011), on page 307, gives yet another way of assessing convergent validity: he fits a CFA, then asks whether “the majority” of the variances of the observed variables have been explained, IE whether the standardized residual variances are <50. I guess the idea is that the amount of variance explained for a variable by a factor depends on how correlated In his words:\n\n[in reference to one of his models:] [the] model fails to explain the majority (> .50) of variance for a total of four out of eight indicators, which indicates poor convergent validity.\n\n\n\n\nHe also invokes the concept of reliability with reference\nAll-in-all, this provides fine evidence of convergent validity because the loadings are all significant and positive?\n\n\n2.2.5 Factor Correlations and Discriminant Validity\nNext let’s look at the estimated correlations between the factors. If my hypothesis H1 is true then we should expect all of the factors to be pretty uncorrelated from each other, but if H2 is true then we should expect MAP and MAV to be super correlated with each other, because H2 thinks there’s no such thing as MAP and MAV – there’s just one big ‘Mastery’ factor:\n\n### Make a nicer version of the correlation matrix of the factors\n  \nh1.summary$pe %>% \n  \n  as_tibble() %>% \n \n  # Keep only the rows with info on factor loadings\n  slice(25:34) %>% \n \n  select(lhs, rhs, std.lv) %>% \n  \n  mutate(\n    std.lv = round(std.lv, 2),\n    across(everything(), as.character)\n  ) %>% \n  \n  pivot_wider(\n    names_from = \"lhs\", \n    values_from = \"std.lv\",\n    values_fill = \" \" \n  ) %>% \n  \n  column_to_rownames(\"rhs\") %>% \n  \n  knitr::kable(caption = \"Correlation matrix of the factors\")\n\n\nCorrelation matrix of the factors\n\n\n\nmap\nmav\npap\npav\n\n\n\n\nmap\n1\n\n\n\n\n\nmav\n0.91\n1\n\n\n\n\npap\n0.06\n0.14\n1\n\n\n\npav\n0.07\n0.21\n0.96\n1\n\n\n\n\n\nInteresting – the ‘Mastery’ factors and the ‘Performance’ factors each seem to be very correlated with each other, while being nice and uncorrelated with the two factors that make up the other. This suggests that we have bad discriminant validity between the imagined two types of ‘Mastery’ and two types of ‘Performance’ – the model can’t really tell them apart as separate things. This makes it harder for me to argue that they are in fact separate things. This is a blow to both H1 and H2.\nGorsuch (1983) suggests we go a step further and do some additional modelling to assess the degree of discriminant validity here:\n\n“[fit the model] with the qualification that the correlations between one or more of the constructs being tested for discriminant validity is one. The difference between chi-squares from [this model vs the model where the correlations are allowed to freely vary] tests whether the constructs have a correlation significantly less than 1.0. If the correlation between the factors for the two constructs is not significantly different from 1.0, the difference chi-square will be insignificant. This means the null hypothesis of no discriminatory validity would be accepted. If the difference chi-square is significant, then the null hypothesis is rejected and the model that assumes discriminatory validity by allowing the correlation to be less than one is the more appropriate one.”\n\nThis has the flavour of a likelihood-ratio test. Let’s do it. First we need to fit the model where the correlation between the Mastery factors and the correlation between the ‘Performance’ factors are both constrained to be 1:\n\n# Define the relationships from my hypothesis\nh1_orthogonal.definition <- \n'map=~ags1+ags5+ags7\nmav=~ags2+ags6+ags12\npap=~ags3+ags9+ags11\npav=~ags4+ags8+ags10\n\nmap ~~ 1*mav\npap ~~ 1*pav\n'\n\n# Fit the model\nh1_orthogonal.fit <- cfa(\n  data  = dat_ags,\n  model = h1_orthogonal.definition\n)\n\n# Compare the goodness-of-fit statistics for the two models\nanova(h1.fit, h1_orthogonal.fit) %>% \n  \n  knitr::kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDf\nAIC\nBIC\nChisq\nChisq diff\nDf diff\nPr(>Chisq)\n\n\n\n\nh1.fit\n48\n14088.14\n14209.28\n328.3120\nNA\nNA\nNA\n\n\nh1_orthogonal.fit\n50\n14096.44\n14209.50\n340.6065\n12.29456\n2\n0.0021393\n\n\n\n\n\nLooks like the reduction in chi-squared goodness-of-fit is statistically significant when we force the within-skill factors to be perfectly correlated. So, according to the Gorsuch (1983) quote above, we can reject the null hypothesis that the within-skill factors are perfectly correlated. This gives a justification for continuing to distinguish between them as separate factors, and helps me make a believable claim that my posited factors have discriminant validity.\nActually, I think another way we could have done this would be to just fit the model where we just define one big factor for ‘Mastery’ and one big factor for ‘Performance’. I tried this and it returned even worse fit, which means the extra parameters (the correlation parameters) are significantly improving fit in the pure h1 model.\n\n\n2.2.6 Residual Variances\nThe thing to notice here is that the observables with the biggest loadings will also have the smallest residual variances, unsurprisingly. Be sure to focus on the Std.all column when doing these assessments, because that’s what this person does. This lets you do fair comparisons between the loadings and residual variance parameters, since it constraints them all to the scale of a correlation coefficient, IE [-1, 1]. I SHOULD FIGURE OUT HOW THIS ALL PLAYS IN FOR FIGURING OUT CONVERGENT VALIDITY – I THINK GORSUCH SAYS THE WITHIN-FACTOR LOADINGS SHOULDN’T BE SIGNIFICANTLY DIFFERENT FROM EACH OTHER? FIND THAT QUOTE\n\n\n2.2.7 Model ‘Selection’\nThe authors do some model comparison of goodness-of-fit based on different estimation methods, but they don’t mention convergent or discriminant validity as an important part of model ‘selection’."
  },
  {
    "objectID": "cfa.html#example-2",
    "href": "cfa.html#example-2",
    "title": "2  CFA",
    "section": "2.3 Example 2:",
    "text": "2.3 Example 2:\nUSE THE EXAMPLE FROM THIS BOOK INSTEAD: http://www.kharazmi-statistics.ir/Uploads/Public/book/Methodology%20in%20the%20Social%20Sciences.pdf\n\ndat_ff <- foreign::read.spss('data/finch-and-french/performance.data.sav')\n\n# Seems like I need to only use the first 12 columns I think?\ndat_ff <- dat_ff %>% \n  \n  as_tibble() %>% \n  \n  select(1:12)\n\nNext we’ll do another example from Finch (2015), from the SEM chapter on page 62. They say it is important to CFA first before testing the relationships between the latent variables a la SEM, because we first want to make sure those latent variables actually seem good. This example uses a different dataset than the previous one.\n\n[W]e must ascertain whether the proposed model structure is supported by our data, which we will do by fitting a CFA to each of the latent variables…\n\nThe authors fit a CFA for each of the latent variables in isolation, namely Mastery, Self-Oriented Perfectionism, and ‘ATTC’, which seems to mean ‘Attention Control’"
  },
  {
    "objectID": "cfa.html#cool-ecology-example-i-should-do-instead",
    "href": "cfa.html#cool-ecology-example-i-should-do-instead",
    "title": "2  CFA",
    "section": "2.4 Cool ecology example I should do instead:",
    "text": "2.4 Cool ecology example I should do instead:\nhttps://www.usgs.gov/centers/wetland-and-aquatic-research-center/science/quantitative-analysis-using-structural-equation"
  },
  {
    "objectID": "cfa.html#example-3",
    "href": "cfa.html#example-3",
    "title": "2  CFA",
    "section": "2.5 Example 3:",
    "text": "2.5 Example 3:\nNow we’ll look at an example from Kline (2011), chapter 13.\nLoad the data:\n\ndat_kline <- read_csv('data/kline/kabc-amos.csv')\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n\n\nRows: 11 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): rowtype_, varname_\ndbl (8): HM, NR, WO, GC, Tr, SM, MA, PS\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "cfa.html#example-4",
    "href": "cfa.html#example-4",
    "title": "2  CFA",
    "section": "2.6 Example 4:",
    "text": "2.6 Example 4:\nLastly, let’s walk through an example from the lavaan documentation\n\n\n\n\nFinch, French, W. Holmes. 2015. Latent Variable Modeling with r.\n\n\nGorsuch, Richard L. 1983. Factor Analysis, 2nd Edition.\n\n\nKline, Rex B. 2011. Principles and Practice of Structural Equation Modeling."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Finch, French, W. Holmes. 2015. Latent Variable Modeling with\nr.\n\n\nGorsuch, Richard L. 1983. Factor Analysis, 2nd Edition.\n\n\nKline, Rex B. 2011. Principles and Practice of Structural Equation\nModeling."
  }
]